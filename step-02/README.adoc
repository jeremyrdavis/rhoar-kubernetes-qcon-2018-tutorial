= Step 2 : Testing

NOTE: Testing asynchronous code is not easy!

TODO: Why?

This is no shortage of testing frameworks in the Java space.  We will even leverage more than one in this workshop!

We will start with JUnit 5.  In case you haven't used JUnit 5 yet it is a rewrite of the most popular (maybe) Java testing framework.  It has a number of interesting new features, including:

* nested tests,
* the ability to give a human-readable description of tests and test cases,
* a modular extension mechanism that is more powerful than the JUnit 4 runner mechanism (@RunWith annotation),
* conditional test execution,
* parameterized tests, including from sources such as CSV data,
* the support of Java 8 lambda expressions in the reworked built-in assertions API,
* support for running tests previously written for JUnit 4.

INFO: You can read more about JUnit 5 here: https://junit.org/junit5/docs/current/user-guide/

The first step is to add JUnit and Vert.x's Unit Testing support.  Open the pom.xml and add the following properties just below the vertx-maven-plugin (line 17):

[source]
````
        <!-- Testing properties -->
        <junit-jupiter.version>5.1.0</junit-jupiter.version>
        <maven-surefire-plugin.version>2.19</maven-surefire-plugin.version>
        <junit-platform-surefire-provider.version>1.0.1</junit-platform-surefire-provider.version>
        <assertj-core.version>3.8.0</assertj-core.version>    </properties>
````

Then add the following dependencies below the vertx-core dependency (line 38):

[source,xml]
```
<!-- Test dependencies -->
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-junit5</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.vertx</groupId>
        <artifactId>vertx-web-client</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>${junit-jupiter.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-params</artifactId>
        <version>${junit-jupiter.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.assertj</groupId>
        <artifactId>assertj-core</artifactId>
        <version>${assertj-core.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>${junit-jupiter.version}</version>
        <scope>test</scope>
    </dependency>
```

NOTE: What about JUnit 5?  The vertx-junit5 library makes asynchronous testing easy and integrates easily with any assertion library.  We will see some of this later today.

Create a new package in the test folder with the same name as the package containing MainVerticle ("io.vertx.example" if you accepted Maven's prompts on generation.)

Create a new Java class named "MainVerticleTest" or something equally creative.  Type the following content:

[source, java]
```
package com.redhat.qcon;

import io.vertx.core.Vertx;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.codec.BodyCodec;
import io.vertx.junit5.Checkpoint;
import io.vertx.junit5.Timeout;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@DisplayName("MainVerticle Test")
@ExtendWith(VertxExtension.class)                                         <1>
class MainVerticleTest {


    @Test
    @Timeout(value = 5, timeUnit = TimeUnit.SECONDS)                      <2>
    @DisplayName("MainVerticle startup test")
    void testMyApplication(Vertx vertx, VertxTestContext context) {       <3>
        assertEquals(true, false);                                        <4>
    }
}
```

. @ExtendWith(VertxExtension.class) this annotation is a new feature that is more powerful than the previous @RunWith.  @ExtendWith can take multiple classes, but in this case we will only be using the VertxExtension.
The Vert.x extension does 2 important things:
* It (optionally) injects instances of Vertx and VertxTestContext when a test method has arguments of these types, and
* It ensures that the JUnit test runner waits for the asynchronous operations to complete even when the test method execution exits.
. The @Timeout annotation will force our test to fail after a specified time (surprise, surprise.)  It is a good idea to add a timeout when testing asynchronous code
. Tests should always fail first just so that you know the test is actually catching failing conditions.  Our cycle is "RED, GREEN, REFACTOR," so we need to start with red.

Run your test either in your IDE or in a terminal.  If your tests passes raise your hand and ask one of the Red Hat guys for help:

