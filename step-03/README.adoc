= Step 3 : Creating a Vert.x Service

=== 3.1 Update Our "Hello, World" Project
It's time to get some real work done and start returning insults.  
We will add a Service to our existing, skeletal application that calls two existing microservices: one that returns nouns and one that returns adjectives.

=== 3.2 Update pom.xml
We will need to add some additional libraries for this microservice:

* vertx-web-api-contract
* vertx-rx-java2
* vertx-service-proxy
* vertx-sockjs-service-proxy
* vertx-config-kubernetes-configmap
* vertx-codegen
* vertx-lang-js

To save time there is a complete pom.xml in this directory.  Copy and paste the pom.xml into your dirctory.  We will look at the specific additions as we use them in the tutorial.

link:pom.xml [Open the pom.xml]

=== 3.3 Add Your New Project To GitHub

```
$ git init
$ git add pom.xml src
$ git commit -am 'Initial import'
$ git push origin master
```
=== 3.4 Get Ready to Test

We will be following the RED-GREEN-REFACTOR pattern of Test Driven Development.  We've already used Vert.x' JUnit-compatible library vertx-unit.  

Personally, we prefer BDD style tests, so for this workshop and will be using the SpockFramework.   The Spock dependencies have already been added to our POM but are listed below so that you can familiarize yourself with them.

```
<!-- Optional dependencies for using Spock -->
<dependency> <!-- use a specific Groovy version rather than the one specified by spock-core -->
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-all</artifactId>
    <version>2.4.13</version>
</dependency>
<dependency> <!-- enables mocking of classes (in addition to interfaces) -->
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy</artifactId>
    <version>1.6.5</version>
    <scope>test</scope>
</dependency>
<dependency> <!-- enables mocking of classes without default constructor (together with CGLIB) -->
    <groupId>org.objenesis</groupId>
    <artifactId>objenesis</artifactId>
    <version>2.5.1</version>
    <scope>test</scope>
</dependency>
```

We have also added the gmavenx-plugin required by the SpockFramework and added the Surefire and JaCoCo plugins for tests and code coverage:

```
<plugin>
    <!-- The gmavenplus plugin is used to compile Groovy code. To learn more about this plugin,
    visit https://github.com/groovy/GMavenPlus/wiki -->
    <groupId>org.codehaus.gmavenplus</groupId>
    <artifactId>gmavenplus-plugin</artifactId>
    <version>1.6</version>
    <executions>
        <execution>
            <goals>
                <goal>compile</goal>
                <goal>compileTests</goal>
            </goals>
        </execution>
    </executions>
</plugin>
<plugin>    <!-- Configure the Maven SureFire plugin to use Groovy Spec files for test -->
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.20.1</version>
    <configuration>
        <useFile>false</useFile>
        <includes>
            <include>**/*Spec.java</include>
        </includes>
    </configuration>
</plugin>
<plugin>    <!-- Configure JaCoCo to be able to extract code coverage information -->
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.7.6.201602180812</version>
    <executions>
        <execution>
            <id>jacoco-initialize</id>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>jacoco-site</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```
=== 3.5 Requirements 

Our service will call two other microservices so it will need to know where the noun and adjective services are located.  Our service also needs to know where to serve its' own results.

Following one of the tenets of 12 Factor Applications, we will want to store our application’s configuration in the deployment environment instead of in our code. Vert.x makes this easy painless by providing a comprehensive set of APIs for loading the application’s configuration. 

In our case, we are going load our configuration from three possible locations: 

* a default set of parameters packaged with the application
* an external location within the Docker container
* in Kubernetes by using Kubernetes ConfigMaps

So our first step will be to implement the necessary configuration for our service so our first test will verify that the configuration exists.

==== 3.5.1 Write a Test

. Create a folder "groovy" under src/test
. Create a package structure "com.redhat.qcon.insult."
. Create a Groovy script "MainVerticleSpec.groovy"

Complete MainVerticleSpec with the following:

```
package com.redhat.qcon.insult

import io.vertx.core.Future
import io.vertx.core.Vertx
import spock.lang.Specification
import spock.util.concurrent.AsyncConditions

class MainVerticleSpec extends Specification {

    def 'Test Vert.x configuration loading'() {
        given: 'An instance of Vert.x'  // (1)
        def vertx = Vertx.vertx()
        and: 'An instance of a Vert.x Future'  // (2)
        def fut = Future.future()
        and: '''An instance of Spock's AsyncConditions'''
        def async = new AsyncConditions(1)
        and: 'The Verticle under test'
        def underTest = new MainVerticle()

        when: 'We attempt to deploy the main Verticle'  // (3)
        vertx.deployVerticle(underTest, fut.completer())

        then: 'Expect that the correct configuration is found and loaded'
        fut.setHandler({ res ->
            async.evaluate {
                def config = underTest.loadedConfig
                assert res.succeeded() // (4)
                assert config.getJsonObject('http').getInteger('port') == 8080 // (5)
            }
        })

        cleanup: 'Await the async operations'  // (8)
        async.await(3600)
        vertx.close()
    }
}
```

Run the test with 

```
mvn clean test
```

The test should fail beacuase our MainVerticle already doing enought to pass.  If your test doesn't pass raise your hand and ask one of the Red Hat guys for help.

=== 3.6 Passing the Test

==== 3.6.1 Create the Default Configuration

Let's create a file to store our default configuration.  Create a new file: "insult_default_config.json" in the "src/main/resources" directory.  Add the following content:

[source, json]
```
{
  "noun": {
    "host": "noun-service",
    "port": 80
  },
  "adjective": {
    "host": "adjective-service",
    "port": 80
  },
  "http": {
    "address": "0.0.0.0",
    "port": 8080
  }
}
```

[source, java]
```
package com.redhat.qcon;

import io.reactivex.Maybe;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.Future;
import io.vertx.core.json.JsonObject;
import io.vertx.reactivex.config.ConfigRetriever;
import io.vertx.reactivex.core.AbstractVerticle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MainVerticle extends AbstractVerticle {

    private static final Logger LOG = LoggerFactory.getLogger(MainVerticle.class);

    Maybe<JsonObject> initConfigRetriever() {                                   // (1)
        // Load the default configuration from the classpath
        LOG.info("Configuration store loading.");
        ConfigStoreOptions defaultOpts = new ConfigStoreOptions()               // (2)
                .setType("file")
                .setFormat("json")
                .setConfig(new JsonObject().put("path", "insult_default_config.json"));

        // Load container specific configuration from a specific file path inside of the
        // container
        ConfigStoreOptions localConfig = new ConfigStoreOptions()               // (3)
                .setType("file")
                .setFormat("json")
                .setConfig(new JsonObject().put("path", "/opt/docker_config.json"))
                .setOptional(true);

        // When running inside of Kubernetes, configure the application to also load from
        // a ConfigMap
        ConfigStoreOptions confOpts = new ConfigStoreOptions()                  // (4)
                .setType("configmap")
                .setConfig(new JsonObject()
                        .put("name", "insult-config")
                        .put("optional", true)
                );

        // Add the default and container config options into the ConfigRetriever
        ConfigRetrieverOptions retrieverOptions = new ConfigRetrieverOptions()  // (5)
                .addStore(defaultOpts)
                .addStore(localConfig)
                .addStore(confOpts);

        // Create the ConfigRetriever and return the Maybe when complete
        return ConfigRetriever.create(vertx, retrieverOptions)
                              .rxGetConfig()
                              .toMaybe();                                       // (6)
    }

    @Override
    public void start(Future<Void> startFuture) {

        initConfigRetriever()                                                   // (7)
                .doOnError(startFuture::fail)                                   // (8)
                .subscribe(c -> {
                    LOG.info(c.encodePrettily());
                    context.config().mergeIn(c);                                // (9)
                    startFuture.complete();                                     // (10)
                });
    }
}
```
. Let's take a look at what this test is checking:
. Define a new method which returns a Single with the configuration
. Create an instance of ConfigStoreOptions to load the default config from the classpath
. Create an instance of ConfigStoreOptions to load configuration data from inside a Docker container
. Create an instance of ConfigStoreOptions to load configuration data from Kubernetes ConfigMaps
. Attach the ConfigStoreOptions to the ConfigRetrieverOptions
. Return the RxJava2 Maybe which may be completed at a later time
. From inside of the start method, call initConfigRetriever
. Set an error handler for the Single which will fail the Verticle deployment when an error is encountered
. Merge the loaded configuration into the global Vert.x configuration
. Complete the startFuture successfully

Re-run the test with 

```
mvn clean test
```

The test should now pass.  If your test fails raise your hand and ask one of the Red Hat guys for help.  

NOTE: If you are running the test in an IDE you may have to rerun the test from the MainVerticleSpec.groovy file.


