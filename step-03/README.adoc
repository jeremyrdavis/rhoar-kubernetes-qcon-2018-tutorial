= Step 3 : Create a new project

=== 3.1 Create a Vert.x Project
First things first create a new directory for your work.  If you are using Windows you should probably create a folder directly on the C drive to prevent any weirdness that could arise from path names.

From inside that directory run the following maven command :

```
mvn io.fabric8:vertx-maven-plugin:1.0.13:setup -DvertxVersion=3.5.1 
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Stub Project (No POM) 1
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- vertx-maven-plugin:1.0.13:setup (default-cli) @ standalone-pom ---
[INFO] No pom.xml found, creating it in /home/dphillips/Documents/RedHat/Workspace/rhoar-kubernetes-qcon-2018/insult-service
Set the project groupId [io.vertx.example]: com.redhat.qcon
Set the project artifactId [my-vertx-project]: insult-service
Set the project version [1.0-SNAPSHOT]: 1.0.0-SNAPSHOT
Set the vertcile class name [MainVerticle]:
[INFO] Creating verticle MainVerticle
[INFO] Creating directory /home/dphillips/Documents/RedHat/Workspace/rhoar-kubernetes-qcon-2018/insult-service/src/main/java/com/redhat/qcon
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 34.510 s
[INFO] Finished at: 2018-05-21T12:07:46-04:00
[INFO] Final Memory: 9M/166M
[INFO] ------------------------------------------------------------------------
```
This will create a new Maven POM file populated based on the values you entered during the setup.

=== 3.2 Update pom.xml
After the POM file has been created, we will need to add some additional libraries for this microservice:

* vertx-web-api-contract
* vertx-rx-java2
* vertx-service-proxy
* vertx-sockjs-service-proxy
* vertx-config-kubernetes-configmap
* vertx-codegen
* vertx-lang-js

To save time there is a complete pom.xml in this directory.  Copy and paste the pom.xml into your dirctory.  We will look at the specific additions as we use them in the tutorial.

link:pom.xml [Open the pom.xml]

=== 3.3 Add Your New Project To GitHub

```
$ git init
$ git add pom.xml src
$ git commit -am 'Initial import'
$ git push origin master
```
=== 3.4 Get Ready to Test

We've already used Vert.x' JUnit-compatible library vertx-unit.  Personally, we prefer BDD style tests, so for this workshop and will be using the SpockFramework.   The Spock dependencies have already been added to our POM.

```
<!-- Optional dependencies for using Spock -->
<dependency> <!-- use a specific Groovy version rather than the one specified by spock-core -->
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-all</artifactId>
    <version>2.4.13</version>
</dependency>
<dependency> <!-- enables mocking of classes (in addition to interfaces) -->
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy</artifactId>
    <version>1.6.5</version>
    <scope>test</scope>
</dependency>
<dependency> <!-- enables mocking of classes without default constructor (together with CGLIB) -->
    <groupId>org.objenesis</groupId>
    <artifactId>objenesis</artifactId>
    <version>2.5.1</version>
    <scope>test</scope>
</dependency>
```

We have also added the gmavenx-plugin required by the SpockFramework and added the Surefire and JaCoCo plugins for tests and code coverage:

```
<plugin>
    <!-- The gmavenplus plugin is used to compile Groovy code. To learn more about this plugin,
    visit https://github.com/groovy/GMavenPlus/wiki -->
    <groupId>org.codehaus.gmavenplus</groupId>
    <artifactId>gmavenplus-plugin</artifactId>
    <version>1.6</version>
    <executions>
        <execution>
            <goals>
                <goal>compile</goal>
                <goal>compileTests</goal>
            </goals>
        </execution>
    </executions>
</plugin>
<plugin>    <!-- Configure the Maven SureFire plugin to use Groovy Spec files for test -->
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.20.1</version>
    <configuration>
        <useFile>false</useFile>
        <includes>
            <include>**/*Spec.java</include>
        </includes>
    </configuration>
</plugin>
<plugin>    <!-- Configure JaCoCo to be able to extract code coverage information -->
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.7.6.201602180812</version>
    <executions>
        <execution>
            <id>jacoco-initialize</id>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>jacoco-site</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```
=== 3.5 Our First Test

Our first step will be to verify that our application starts up.

. Create a folder "groovy" under src/test
. Create a package structure "com.redhat.qcon.insult."
. Create a Groovy script "MainVerticleSpec.groovy"

Complete MainVerticleSpec with the following:

```
package com.redhat.qcon.insult

import io.vertx.core.Future
import io.vertx.core.Vertx
import spock.lang.Specification
import spock.util.concurrent.AsyncConditions

class MainVerticleSpec extends Specification {

    def 'Test Vert.x configuration loading'() {
        given: 'An instance of Vert.x'  // (1)
        def vertx = Vertx.vertx()
        and: 'An instance of a Vert.x Future'  // (2)
        def fut = Future.future()
        and: '''An instance of Spock's AsyncConditions'''
        def async = new AsyncConditions(1)
        and: 'The Verticle under test'
        def underTest = new MainVerticle()

        when: 'We attempt to deploy the main Verticle'  // (3)
        vertx.deployVerticle(underTest, fut.completer())

        then: 'Expect that the correct configuration is found and loaded'
        fut.setHandler({ res ->
            async.evaluate {
                def config = underTest.loadedConfig
                assert res.succeeded() // (4)
                assert config.getJsonObject('http').getInteger('port') == 8080 // (5)
            }
        })

        cleanup: 'Await the async operations'  // (8)
        async.await(3600)
        vertx.close()
    }
}
```

Run the test with 

```
mvn clean test
```

The test should pass beacuase our MainVerticle is already doing enought to pass.  If your test doesn't pass raise your hand and ask one of the Red Hat guys for help.

=== 3.6 Write a New Test

